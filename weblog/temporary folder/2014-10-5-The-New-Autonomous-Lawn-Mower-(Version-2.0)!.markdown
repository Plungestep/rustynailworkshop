---
layout: post
title: The New Autonomous Lawn Mower (Version 2.0)!
tags: [frontpage, electronics, experiment]
image: '/images/posts/2014-10-5/mower.jpg'
---

Our first generation robotic lawn mower wasn’t the complete success that we hoped it would be.  It started off simple enough, as a remote controlled lawn mower, using a hobby RC controller and some used wheelchair motors.  With some simple steel framing, the lawn mower was durable, easy to drive, and worked surprisingly well for a remote controlled mower.  Well, it was a little hard to steer in a straight line.  That’s why I added a GPS.  However, when I attempted to add the GPS and inertial guidance functionality to see if it would operate autonomously, it failed miserably.  Although it would navigate to preset waypoints, it would only find one waypoint on the North side of lawn, and one waypoint on the South side.  Obviously, this wouldn’t be sufficient to operate as an autonomous lawn mower.  The goal here was not a random pattern, but a parallel path mowed lawn.

Everything changed one day when I found out about Swift Navigation’s [Piksi RTC GPS](https://www.swiftnav.com/piksi-multi).  With Real Time Kinematics (the RTK part), it operates using two GPS units and a radio link between them.  This allows it to calculate incredibly accurate positions, in relation to each GPS.  What this means is that I can leave one GPS unit at a fixed location, put the other one on the robotic lawn mower, and have it calculate coordinates from the fixed GPS down to 2 centimeter accuracy.  Yes, 2 centimeters!  This meant that a robotic lawn mower was suddenly possible again.
![Piksi GPS](/images/posts/2014-10-5/piksi.jpg)
Rather than use the heavy and large steel frame from the original robotic lawn mower, I decided to upgrade everything.  Using [80/20](http://8020.net/) extruded aluminum tubing, I was able to construct a smaller frame that allowed unlimited possibilities for mounting sensors and external components.  I moved the batteries up over and between the rear wheels, dropped the motors down horizontal, and increased the size of the tires.  The previous tires tended to slip on wet grass.  The new tires are Sno-Hog tires, and provide incredible grip on all surfaces.
![Wheel](/images/posts/2014-10-5/wheel.jpg)
I then added on-board chargers (one for the mower battery and one for the wheelchair batteries) and wired them to a single plug so it would be easy to recharge at any outlet.
![Charger](/images/posts/2014-10-5/charger.jpg)
The new robotic mower design also included a box above the mower, made out of the 80/20 framing and acrylic glass, which houses the electronics.  Two fans control the temperature inside, with one blowing in and one blowing out to generate a cross breeze.  The brains of the robot are an Intel NUC with an i5 processor, 8 GB of RAM, a 120 GB solid state hard drive running Windows 8.1, and four USB 2 ports.  Eventually I put a hinge on the top piece of acrylic and the entire electronics section was fully enclosed from the elements.  Not that I planned to drive this in the rain, especially with expensive electronics on board.
![Front Camera](/images/posts/2014-10-5/camera.jpg)
For vision, a Logitech HD Pro webcam (C920) was mounted on an L-shaped bracket.  The camera has a tripod mount, so it mounts easily to the 80/20 framing.  The camera has an attached USB cable, so it plugged in easily to the PC, using USB port #1.  The PC was also configured to use an 802.11ac Wi-Fi card, and broadcasts its own Wi-Fi network.  I then set up the PC using Remote Desktop so I could run code on the machine while the robot was driving.  Using the webcam, I get a nice video feed to monitor the progress.  Using OpenCV software, I should be able to instruct the robot not to drive over anything that is not green grass colored.
![Arduino Clone](/images/posts/2014-10-5/arduino.jpg)
The Piksi GPS was mounted inside the electronics enclosure, but an antenna was added on a tall mast above the rest of the electronics, so it had a clear view of the sky.  This used USB port #2.  An Arduino clone was added to provide PID control of the fans, which could slow them down to a stop when the outside temperature was exceptionally cold (for when I use it as a snowplow).  This used USB port #3, which provided power to the board and established a link for continuous serial port communication.  This will also allow me to add additional sensors to the Arduino, and have it communicate back to the main software running on the PC.
![Emergency Stop Button](/images/posts/2014-10-5/stop.jpg)
To provide safety during operation, I devised a way to cut power to the main lawnmower motor and blade, and to stop the wheelchair drive motors while allowing the computer to continue to run, all with the press of an emergency stop switch on the top of the electronics enclosure.  This switch is a normally closed switch which opens when pressed, and locks into position once pressed, so you have to twist it to turn it back on.  The switch is wired to two relays which can each handle 30 amps of current.  When the main power switch is turned on, the relays engage and remain engaged unless the emergency stop switch is pressed.  The main power switch controls all power, and disconnects power to the PC.  I wanted to be able to shut down the PC safely when the emergency switch was pressed, but all moving parts of the mower had to stop immediately.  I also tried to wire in a remote controlled emergency switch, but found out the the remote control receiver did not have power until everything was powered on, so the switch couldn’t close and the whole unit couldn’t power up.  It was a catch-22 and I removed it for the time being.
![Relays](/images/posts/2014-10-5/relays.jpg)
The motors are still being controlled with a Sabertooth 2×25 motor controller from Dimension Engineering.  It works well, but next time I’d probably add one that had a direct USB connection.  I ended up using packet control and an FTDI cable plugged into USB port #4 on the PC.  The software then sends specific commands addressed to this motor controller, and there is a checksum to verify the correct command was received.  Another fail-safe step.
![FTDI Cable](/images/posts/2014-10-5/ftdi.jpg)
The software on the PC was written in Python for east of integrating it with everything I had to include.  The Piksi site had some sample Python code in Github, which made getting the GPS data easier.  It was fairly straightforward to write the motor controller software, although some initial testing indicates that precise motor control may not be possible without feedback from additional sensors.  For example, making clean 90-degree turns based on motor timing is difficult, and not very reproducible.  Adding rotary encodes to the wheels or inertial sensors may help increase the accuracy.
![Mounted Electronics](/images/posts/2014-10-5/Box.jpg)
I have encountered several problems, especially with the Intel NUC computer.  It seems it is sensitive to voltage fluctuations, and the power circuitry can be easily destroyed by over or under voltages.  I’m currently searching for a new DC-voltage converter so I can take 24 volts and supply 18 volts to the NUC.

At the present time, I have the mower driving with the software code, and I hope to have it controlled to drive to waypoints via GPS shortly.  The Piksi GPS units are working fine, and the accuracy has been verified.  The next plan is to set up boustrophedon cellular decomposition to break the lawn up into logical areas to mow, so the mower finishes in an efficient manner.  This part will be hard, since I have yet to find any examples of boustrophedon code.
